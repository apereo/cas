import java.util.concurrent.ConcurrentHashMap

description = "Apereo Central Authentication Service $version"
defaultTasks "clean", "build"

buildscript {
    repositories {
        mavenCentral()
        gradlePluginPortal()
        maven {
            url "https://maven.eveoh.nl/content/repositories/releases"
        }
    }

    dependencies {
        classpath "gradle.plugin.com.ewerk.gradle.plugins:jaxb2-plugin:1.0.10"
        classpath "org.gradle:test-retry-gradle-plugin:$gradleRetryVersion"
        classpath "com.github.jk1:gradle-license-report:$gradleLicenseVersion"
        classpath "org.springframework.boot:spring-boot-gradle-plugin:$springBootVersion"
        classpath "gradle.plugin.com.gorylenko.gradle-git-properties:gradle-git-properties:$gradleGitVersion"
        classpath "io.franzbecker:gradle-lombok:$gradleLombokVersion"
        classpath "com.github.ben-manes:gradle-versions-plugin:$gradleDependencyVersionsVersion"

        classpath "net.ltgt.gradle:gradle-errorprone-plugin:$gradleErrorProneVersion"
        classpath "org.owasp:dependency-check-gradle:$gradleDependencyCheckVersion"
        classpath "gradle.plugin.com.github.spotbugs.snom:spotbugs-gradle-plugin:$gradleSpotbugsVersion"
        classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:$gradleSonarqubeVersion"
        classpath "com.github.jengelman.gradle.plugins:shadow:$gradleShadowVersion"
        classpath "io.github.gradle-nexus:publish-plugin:$gradleNexusPublishingVersion"
    }
}

ext {
    srcTagMap = new ConcurrentHashMap<File, Set<String>>()

    repositoryUsername = providers.systemProperty("repositoryUsername").forUseAtConfigurationTime().getOrNull()
    repositoryPassword = providers.systemProperty("repositoryPassword").forUseAtConfigurationTime().getOrNull()

    publishSnapshots = providers.systemProperty("publishSnapshots").forUseAtConfigurationTime().present
    publishReleases = providers.systemProperty("publishReleases").forUseAtConfigurationTime().present

    publishFlag = publishSnapshots || publishReleases

    publishMinimalArtifacts = providers.systemProperty("publishMinimalArtifacts").forUseAtConfigurationTime().present

    skipBootifulArtifact = providers.systemProperty("skipBootifulArtifact").forUseAtConfigurationTime().present
    skipErrorProneCompiler = providers.systemProperty("skipErrorProneCompiler").forUseAtConfigurationTime().present

    skipArtifactSigning = providers.systemProperty("skipArtifactSigning").forUseAtConfigurationTime().present

    enableRemoteDebugging = providers.systemProperty("enableRemoteDebugging").forUseAtConfigurationTime().present
    remoteDebuggingSuspend = providers.systemProperty("remoteDebuggingSuspend")
            .forUseAtConfigurationTime().getOrElse("false") == "true" ? "y" : "n"
    generateGitProperties = publishFlag
            || providers.systemProperty("generateGitProperties").forUseAtConfigurationTime().present
    generateTimestamps = publishFlag
        || providers.systemProperty("generateTimestamps").forUseAtConfigurationTime().present

    ci = System.getenv("CI") || providers.systemProperty("CI").forUseAtConfigurationTime().present

    excludedFilesFromTestCoverage = [
        '**/docs/**',
        '**/soap/generated/**',
        '**/com/duosecurity/**',
        '**/support/openid/**',
        '**/**ConfigurationMetadata**',
        '**/**NtlmAuthenticationHandler**',
        '**/**CosmosDb**',
        '**/**NimbusOAuthJacksonModule**',
        '**/**Application**',
        '**/**Application$**',
        '**/**Exception$**',
        '**/**Properties**',
        '**/**Properties$**'
    ]
}

def isArtifactSigningRequired = {
    return publishReleases && !skipArtifactSigning
}

apply plugin: "io.github.gradle-nexus.publish-plugin"
nexusPublishing {
    packageGroup = "org.apereo"
    repositories {
        sonatype {
            stagingProfileId = "11d1ddbbdeae9d"
            username = "${repositoryUsername}"
            password = "${repositoryPassword}"
        }
    }
    
    clientTimeout = java.time.Duration.ofSeconds(120)
    connectTimeout = java.time.Duration.ofSeconds(120)
    transitionCheckOptions {
        maxRetries.set(60)
        delayBetween.set(java.time.Duration.ofMillis(60000))
    }
}

apply from: rootProject.file("gradle/dependencies.gradle")
apply from: rootProject.file("gradle/dependencyUpdates.gradle")

if (!providers.systemProperty("skipSonarqube").forUseAtConfigurationTime().present) {
    apply plugin: "org.sonarqube"

    sonarqube {
        def exclusions = rootProject.excludedFilesFromTestCoverage.join(",")
        def token = providers.systemProperty("SONARCLOUD_TOKEN").forUseAtConfigurationTime()
                .getOrElse(System.getenv("SONARCLOUD_TOKEN"))
        properties {
            property "sonar.host.url", "https://sonarcloud.io"
            property "sonar.projectName", "cas"
            property "sonar.sourceEncoding", "UTF-8"
            property "sonar.java.source", project.targetCompatibility
            property "sonar.organization", "apereo"
            property "sonar.login", token
            property "sonar.coverage.exclusions", exclusions
            property "sonar.java.coveragePlugin", "jacoco"
        }
    }
}

apply plugin: "org.owasp.dependencycheck"
dependencyCheck {
    /*
     * Specifies if the build should be failed if a CVSS score equal
     * to or above a specified level is identified.
     */
    failBuildOnCVSS = 8
    skipTestGroups = true
    skipConfigurations = ['jacocoAgent', 'jacocoAnt', 'optional', 'provided', 'providedCompile', 'providedRuntime',
                          'signatures', 'spotbugs', 'spotbugsPlugins', 'checkstyle', 'errorprone', 'errorproneJavac',
                          'annotationProcessor', 'archives', 'compileOnlyApi ',
                          'tests', 'testRuntimeOnly', 'testRuntimeClasspath', 'testRuntime', 'testImplementation',
                          'testCompileOnly', 'testCompileClasspath', 'testCompile', 'testAnnotationProcessor',
                          'bootArchives', 'bootRunAnnotationProcessor']
    cveValidForHours = 24
    suppressionFile = file("$rootProject.projectDir/style/dependency-check-suppressions.xml")
    analyzers {
        assemblyEnabled = false
        swiftEnabled = false
        cocoapodsEnabled = false
        nodeEnabled = false
        nodeAuditEnabled = false
        autoconfEnabled = false
        cmakeEnabled = false
        pathToDotnet = false
        nuspecEnabled = false
        rubygemsEnabled = false
        pyPackageEnabled = false
        pyDistributionEnabled = false
        nexusEnabled = false
        centralEnabled = false
        bundleAuditEnabled = false
        composerEnabled = false
        opensslEnabled = false
        archiveEnabled = false
    }
}

allprojects {
    apply plugin: "idea"
    apply plugin: "eclipse"
    apply plugin: "java-library"
    apply plugin: "jacoco"

    if (gradle.startParameter.taskNames.any { task -> task.equalsIgnoreCase("install") }) {
        apply plugin: "maven"
    }

    def skipRetry = providers.systemProperty('skipTestRetry').forUseAtConfigurationTime().present
    if (!skipRetry) {
        apply plugin: "org.gradle.test-retry"
    }

    apply from: rootProject.file("gradle/tasks.gradle")

    if (rootProject.generateGitProperties) {
        apply plugin: "com.gorylenko.gradle-git-properties"
    }

    project.ext["forceBootifulArtifact"] = null

    afterEvaluate { project ->
        jacoco {
            toolVersion = "$gradleJacocoVersion"
        }

        if (rootProject.generateGitProperties) {
            gitProperties {
                customProperty 'project.group', project.group
                customProperty 'project.name', project.name
                customProperty 'project.version', project.version
                customProperty 'project.description', project.description
                extProperty = "gitProps"
                keys = ["git.branch", "git.build.time", "git.build.user.name",
                        "git.build.version", "git.commit.id", "git.remote.origin.url"]
            }
        }
    }

    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(project.targetCompatibility)
        }
    }

    idea {
        module {
            downloadSources = false
            downloadJavadoc = false
            jdkName = project.targetCompatibility
            excludeDirs += file(".gradle")
            [".settings", "classes", "bin", "out", "docs", "dependency-cache", "libs",
             "reports", "resources", "test-results", "tmp"].each {
                excludeDirs += file("$buildDir/$it")
            }
        }
    }

    javadoc {
        options.addBooleanOption('html5', true)
        failOnError = providers.systemProperty("ignoreJavadocFailures").forUseAtConfigurationTime().present
        excludes = ['**/generated/**', '**/com/duosecurity/**']
    }

}

subprojects {
    /**
     task dependencyCheckAnalyze(type: org.owasp.dependencycheck.gradle.tasks.Analyze) {Disable analyze in cas-server-core-api and cas-server-core because
     support and webapp sub-projects will include their dependencies transitively.
     enabled = !"${project.name}".contains("cas-server-core")}task allDependenciesInsight(type: DependencyInsightReportTask,
     description: "Produce insight information for all dependencies") {}task allDependencies(type: DependencyReportTask,
     description: "Display a graph of all project dependencies") {}**/

    if (projectShouldBePublished(project)) {
        apply plugin: "maven-publish"
        apply plugin: "signing"
    }

    if (!rootProject.skipErrorProneCompiler) {
        apply plugin: "net.ltgt.errorprone"
    }
    apply from: rootProject.file("gradle/tests.gradle")

    ext.libraries = rootProject.ext.libraries

    configurations {
        tests
        provided
    }

    if (gradle.startParameter.taskNames.any { task -> task.startsWith("jacoco") }) {
        jacocoTestReport {
            reports {
                xml.required.set(true)
                html.required.set(true)
            }
            afterEvaluate {
                classDirectories.setFrom(files(classDirectories.files.collect {
                    fileTree(dir: it, include: ['**/*.*'], exclude: rootProject.excludedFilesFromTestCoverage)
                }))
            }
            sourceSets sourceSets.main
            getExecutionData().setFrom(fileTree(buildDir).include("/jacoco/*.exec"))
        }

        jacocoTestCoverageVerification {
            getExecutionData().setFrom(fileTree(buildDir).include("/jacoco/*.exec"))
            afterEvaluate {
                classDirectories.setFrom(files(classDirectories.files.collect {
                    fileTree(dir: it, include: ['**/*.*'], exclude: rootProject.excludedFilesFromTestCoverage)
                }))
            }
            violationRules {
                rule {
                    element = 'CLASS'
                    limit {
                        minimum = 0.80
                    }
                }
            }
        }
    }

    apply from: rootProject.file("gradle/overrides.gradle")

    /**
     * Apply publishing rules after the build has had a chance to
     * evaluate sub-projects to apply plugins, etc.
     */
    afterEvaluate { project ->
        if (projectShouldBePublished(project)) {
            logger.info "Project ${project.name} should be published"
            apply from: rootProject.file("gradle/maven.gradle")

            publishing {
                publications {
                    def isWarPluginApplied = project.plugins.hasPlugin("war")
                    if (isWarPluginApplied) {
                        logger.info "Project ${project.name} should be published as a WAR"
                        mavenWeb(MavenPublication) {
                            from components.web
                            pom {
                                createPom(it, project)
                            }
                            pom.withXml {
                                createPomRepositories(asNode())
                            }
                        }
                    } else {
                        logger.info "Project ${project.name} should be published as a JAR"
                        mavenJava(MavenPublication) {
                            from components.java
                            if (!rootProject.publishMinimalArtifacts) {
                                artifact tasks['sourcesJar']
                                artifact tasks['resourcesJar']
                                artifact tasks['javadocJar']
                                artifact tasks['testJar']
                            }

                            pom {
                                createPom(it, project)
                            }
                            pom.withXml {
                                createPomRepositories(asNode())
                            }
                        }
                    }
                }

                repositories {
                    if (rootProject.publishReleases) {
                        maven {
                            name "CAS-Releases"
                            url "${releaseRepositoryUrl}"
                            mavenContent {
                                releasesOnly()
                            }
                            credentials {
                                username "${repositoryUsername}"
                                password "${repositoryPassword}"
                            }
                        }
                    }
                    if (rootProject.publishSnapshots) {
                        maven {
                            name "CAS-Snapshots"
                            url "${snapshotsRepositoryUrl}"
                            mavenContent {
                                snapshotsOnly()
                            }
                            credentials {
                                username "${repositoryUsername}"
                                password "${repositoryPassword}"
                            }
                        }
                    }
                }
            }

            signing {
                required = isArtifactSigningRequired
                sign publishing.publications
            }
        }
    }

    artifacts {
        tests testJar
        if (rootProject.publishFlag && !rootProject.publishMinimalArtifacts) {
            archives sourcesJar
            archives javadocJar
            archives resourcesJar
        }
        archives testJar
    }

    sourceSets {
        main {
            compileClasspath += configurations.provided
            runtimeClasspath += configurations.provided

            java {
                srcDirs = ["${projectDir}/src/main/java"]
            }
            resources {
                srcDirs = ["${projectDir}/src/main/resources"]
            }
        }
        test {
            java {
                srcDirs = ["${projectDir}/src/test/java"]
            }
            resources {
                srcDirs = ["${projectDir}/src/test/resources"]
            }
        }
    }

    ext.buildJarFile = new File(project.buildDir, "libs/${project.name}-${project.version}.jar")

    [compileTestJava, compileJava].each {
        if (rootProject.generateGitProperties) {
            it.dependsOn("generateGitProperties")
        }

        it.options.fork = true
        it.options.incremental = true

        def casCompilerArgs = ["-parameters"]

        def terminateCompilerOnWarning = project.ext.properties.get("terminateCompilerOnWarning", true)
        if (terminateCompilerOnWarning) {
            casCompilerArgs.add("-Werror")
        }

        if (!rootProject.skipErrorProneCompiler) {
            it.options.errorprone.allErrorsAsWarnings = false
            it.options.errorprone.disableWarningsInGeneratedCode = true
            it.options.errorprone.errorproneArgs = ['-Xep:MissingOverride:OFF',
                                                    '-Xep:HidingField:OFF',
                                                    '-Xep:MissingSummary:OFF',
                                                    '-Xep:SameNameButDifferent:OFF']
            it.options.errorprone.excludedPaths = ".*com/duosecurity.*"
            casCompilerArgs.add("-XDcompilePolicy=byfile")
        }
        it.options.compilerArgs += casCompilerArgs
    }

    if (projectRequiresLombok(project)) {
        apply plugin: "io.franzbecker.gradle-lombok"
        lombok {
            version = "$lombokVersion"
            sha256 = ""
        }
        installLombok.enabled = false
    }

    jar {
        manifest {
            attributes(
                    "Automatic-Module-Name": project.name,
                    "Implementation-Title": project.name,
                    "Implementation-Vendor": project.group,
                    "Created-By": project.group)
            if (generateTimestamps) {
                attributes("Implementation-Date": java.time.ZonedDateTime.now(ZoneId.systemDefault()))
            }

            attributes(
                    "Specification-Version": "${-> project.ext.has("gitProps") ? project.ext.gitProps['git.commit.id'] : 'N/A'}",
                    "Implementation-Version": project.version)
        }
    }

    if (!providers.systemProperty("skipCheckstyle").forUseAtConfigurationTime().present && projectShouldBePublished(project)) {
        apply plugin: "checkstyle"
        checkstyle {
            configProperties = [
                    "checkstyle.suppressions.file" : new File(rootDir, "style/checkstyle-suppressions.xml"),
                    "checkstyle.importcontrol.file": new File(rootDir, "style/import-control.xml")
            ]
            configFile = new File(rootDir, "style/checkstyle-rules.xml")
            ignoreFailures false
            showViolations true
            toolVersion "${checkstyleVersion}"
        }
    }

    if (!providers.systemProperty("skipSpotbugs").forUseAtConfigurationTime().present && projectShouldBePublished(project)) {
        apply from: rootProject.file("gradle/spotbugs.gradle")
    }

    if (gradle.startParameter.taskNames.any { task -> task.equalsIgnoreCase("checkLicense") }) {
        apply plugin: "com.github.jk1.dependency-license-report"
        licenseReport {
            outputDir = "$projectDir/build/licenses"
            projects = project
            excludeOwnGroup = true
            configurations = ['runtimeClasspath']
            filters = [new com.github.jk1.license.filter.ExcludeTransitiveDependenciesFilter()]
            allowedLicensesFile = new File("$rootProject.projectDir/etc/allowed-licenses.json")
        }
        checkLicense.finalizedBy outputDependenciesWithoutLicense
    }

    dependencies {

        implementation libraries.aspectj
        implementation libraries.validationapi

        api libraries.jaxb
        api libraries.swaggerannotations
        api libraries.slf4j
        api libraries.guava
        api libraries.commons
        api libraries.jodatime
        api libraries.inspektr
        api libraries.persondirectory
        api libraries.spring
        api libraries.bytebuddy
        api libraries.jackson
        api libraries.httpclient
        api libraries.quartz
        api libraries.bvalidator
        api libraries.groovy
        api libraries.caffein
        api libraries.springcloud
        api libraries.springboot
        api libraries.springsecurity
        api libraries.springwebflow
        api libraries.javaxel
        api libraries.javax

        annotationProcessor libraries.springindexer

        if (!providers.systemProperty("skipSpotbugs").forUseAtConfigurationTime().present && projectShouldBePublished(project)) {
            spotbugsPlugins libraries.findbugscontrib
            spotbugsPlugins libraries.findbugssec
        }

        if (!providers.systemProperty("skipErrorProneCompiler").forUseAtConfigurationTime().present) {
            errorprone "com.google.errorprone:error_prone_core:$errorProneVersion"
            errorproneJavac "com.google.errorprone:javac:$errorproneJavacVersion"
        }
        testImplementation libraries.tests
        testImplementation libraries.log4j

        if (!ci) {
            testRuntimeOnly "org.junit.platform:junit-platform-suite-engine:$junitPlatformVersion"
        }
        compileOnlyApi libraries.spotbugsannotations
    }
}

if (!gradle.startParameter.excludedTaskNames.contains("javadoc") || rootProject.publishFlag) {
    tasks.withType(Javadoc) {
        source subprojects.collect { project -> project.sourceSets.main.allJava }
        destinationDir = new File(buildDir, "javadoc")
        classpath = files(subprojects.collect { project -> project.sourceSets.main.compileClasspath })
        options.addBooleanOption('html5', true)
        failOnError = providers.systemProperty("ignoreJavadocFailures").forUseAtConfigurationTime().present
    }

    task aggregateJavadocsIntoJar(type: Jar, dependsOn: javadoc, description: "Aggregate all Javadocs into a single directory") {
        archiveClassifier.set("javadoc")
        from javadoc
    }
}

if (rootProject.publishFlag) {
    task rootSourcesJar(type: Jar, description: "Build JAR for the root CAS module") {
        archiveBaseName.set("${project.archivesBaseName}")
        from rootProject.file("src")
    }
}

task gradleHome(description: "Display GRADLE_HOME environment variable") {
    doFirst {
        ansi.green "\nexport GRADLE_HOME=" + gradle.gradleHomeDir
    }
}

if (rootProject.publishFlag && !rootProject.publishMinimalArtifacts) {
    artifacts {
        archives aggregateJavadocsIntoJar
        archives rootSourcesJar
    }
}

if (gradle.startParameter.taskNames.any { task -> task.startsWith("jacoco") }) {
    task jacocoMerge(type: JacocoMerge) {
        subprojects.each { subproject ->
            executionData subproject.tasks.withType(Test)
            dependsOn tasks.withType(Test)
        }
        doFirst {
            executionData = files(executionData.findAll { it.exists() })
        }
    }

    task jacocoRootReport(type: JacocoReport) {
        description = 'Generates an aggregate report from all projects'

        subprojects.each {
            if (!it.path.contains(":docs")) {
                it.tasks.withType(Test).each { task -> dependsOn(task) }
            }
        }

        dependsOn jacocoMerge

        additionalSourceDirs.setFrom(files(subprojects.sourceSets.main.allSource.srcDirs))
        sourceDirectories.setFrom(files(subprojects.sourceSets.main.allSource.srcDirs))
        classDirectories.setFrom(
                files(subprojects.sourceSets.main.output).collect {
                    fileTree(dir: it,
                            include: ['**/*.*'],
                            exclude: rootProject.excludedFilesFromTestCoverage
                    )
                })
        //executionData.setFrom(files(subprojects.jacocoTestReport.executionData))
        executionData jacocoMerge.destinationFile

        reports {
            html.required.set(true)
            xml.required.set(true)
            csv.required.set(true)
        }
    }
}

task casVersion(description: "Display current CAS version") {
    doLast {
        println rootProject.version
    }
}

task tomcatVersion(description: "Display current Apache Tomcat version") {
    doLast {
        println "${tomcatVersion}"
    }
}

task signingKey(description: "Display CAS signing key id") {
    doLast {
        println "Signing key: " + project.findProperty("signing.keyId")
    }
}

task verifyRequiredJavaVersion {
    def requiredVersion = JavaVersion.toVersion(project.targetCompatibility)
    if (!JavaVersion.current().isCompatibleWith(requiredVersion)) {
        throw new GradleException("Current Java version ${JavaVersion.current()} does not match required Java version ${requiredVersion}")
    }
}

boolean projectShouldBePublished(Project project) {
    def publishable = !["api", "core", "docs", "support", "webapp"].contains(project.name)
            && !project.getPath().contains("cas-server-documentation")
    if ("${releaseRepositoryUrl}".contains("github.com") && project.getPath().contains("cas-server-support-shell")) {
        // shell is too big for github
        publishable = false
    }
    project.ext.publishable = publishable
}

boolean projectRequiresLombok(Project project) {
    return !["api", "core", "docs", "support", "webapp"].contains(project.name)
            && !project.getPath().contains("cas-server-documentation")
}
